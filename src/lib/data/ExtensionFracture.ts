import { Matrix3x3, scalarProductUnitVectors, Vector3 } from "../types"
import { fromAnglesToNormal } from "../utils/fromAnglesToNormal"
import { Data } from "./Data"
import { FractureStrategy, Tokens } from "./types"
import { HypotheticalSolutionTensorParameters } from "../geomeca"
import { DataStatus } from "./DataDescription"
import { decodePlane } from "../utils/PlaneHelper"

/**
 * @brief Represent an observed and measured joint
 * 
 * An extension fracture is represented by a  Its orientation in space is definedby three parameters, as follows:
 *      Strike: clockwise angle measured from the North direction [0, 360)
 *      Dip: vertical angle, measured downward, between the horizontal and the line of greatest slope in an inclined plane [0, 90]
 *      Dip direction: (N, E, S, W) or a combination of two directions (NE, SE, SW, NW).
 *
 * @category Data
 */
export class ExtensionFracture extends Data {
    protected nPlane: Vector3 = undefined
    protected strategy: FractureStrategy = FractureStrategy.ANGLE

    /*
    description(): any {
        return {
            // Mandatory data: 
            // 0, 1    =  Data number, data type (Extension Fracture and inheriting class: Dilation Band)
            // ------------------------------
            // Plane orientation : 
            // 2, 3, 4 = Strike, dip, dip direction
            mandatory: [2, 3, 4],
            // Optional data:
            // 11, 12 = Deformation phase, relative weight 
            optional: [11, 12]
        }
    }
    */

    initialize(args: Tokens[]): DataStatus {
        const toks = args[0]
        const plane = decodePlane(toks)

        // Calculate the unit vector normal to the Plane
        this.nPlane = fromAnglesToNormal({
            strike: plane.strike,
            dip: plane.dip,
            dipDirection: plane.dipDirection
        })

        // Read position if any
        if (toks[19].length !== 0) this.pos[0] = parseFloat(toks[19])
        if (toks[20].length !== 0) this.pos[1] = parseFloat(toks[20])
        if (toks[21].length !== 0) this.pos[2] = parseFloat(toks[21])

        return plane.result
    }

    check({ displ, strain, stress }: { displ: Vector3, strain: Matrix3x3, stress: Matrix3x3 }): boolean {
        return stress !== undefined
    }

    // This version does not consider the case in which the stress shape ratio R is close to zero (i.e., Sigma 2 = Sigma 3).
    //      In this particular situation, any extension fracture containing Sigma 1 is consistent with the hypothetical stress tensor solution.
    //      In other words, the extension fracture normal is in the plane generated by (Sigma 2, Sigma 3)
    cost({ displ, strain, stress }: { displ: Vector3, strain: HypotheticalSolutionTensorParameters, stress: HypotheticalSolutionTensorParameters }): number {
        const dot = scalarProductUnitVectors({ U: stress.S3_Y, V: this.nPlane })

        switch (this.strategy) {
            case FractureStrategy.DOT: return 1 - Math.abs(dot)
            // Sigma 1 can be oriented in two opposite directions, thus to calculate the minimum angle we take the dot product as positive.
            default: return Math.acos(Math.abs(dot)) / Math.PI
        }
    }

    predict({ displ, strain, stress }: { displ?: Vector3; strain?: HypotheticalSolutionTensorParameters; stress?: HypotheticalSolutionTensorParameters }): number {
        const dot = scalarProductUnitVectors({ U: stress.S3_Y, V: this.nPlane })
        return Math.acos(Math.abs(dot))
    }
}
